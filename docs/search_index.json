[
["ctlsc0x-supply-chain-analytics.html", "Chapter 1 CTLSC0x - Supply Chain Analytics 1.1 Week2 - Unconstrained &amp; Constrained Optimization", " Chapter 1 CTLSC0x - Supply Chain Analytics 1.1 Week2 - Unconstrained &amp; Constrained Optimization 1.1.1 Recitation 1.1.1.1 Unconstrained Straigthforward exercises in modeling optimization without index vectors. \\[ \\textbf{Equation 1:} \\ \\ Minimze \\ \\ y = x^2+2*x-3 \\] Since is an unconstrained quadratic optimization with a single variable, base R package optimizer can solve it f &lt;- function(x){x^2+2*x-3} result &lt;- optimize(f,interval = c(-10,10), maximum = F) print(result) ## $minimum ## [1] -1 ## ## $objective ## [1] -4 Let’s check the result in the plot #Data created for plot, using mutate on the function x &lt;- seq(-10,10,1) data &lt;- data &lt;- data.frame(x) %&gt;% mutate(y = f(x)) #Ploting with a marker on the optimal solution plot_ly(data, x = ~x, y = ~y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_markers(y = result$objective, x = result$minimum) \\[ \\textbf{Equation 2:} \\ \\ Maximize \\ \\ z =-x^2+2*x-y^2 \\] In this equation there is 2 variables, for this case it can be used the base R package optim. f &lt;- function(x,y){-x[1]^2+2*x[1]-x[2]^2} result &lt;- optim(c(1, 1), f) print(result) ## $par ## [1] 4.996335e+54 2.684172e+55 ## ## $value ## [1] -7.454411e+110 ## ## $counts ## function gradient ## 501 NA ## ## $convergence ## [1] 1 ## ## $message ## NULL 1.1.1.2 Constrained 1.1.1.2.1 Banner Chemicals data &lt;- tibble(Type = c(&quot;Profit&quot;,&quot;Plant&quot;,&quot;Additive A&quot;, &quot;Additive B&quot;), High = c(80,1,3,1), Supreme = c(200,1,2,3), Capacity = c(NA,110, 300, 280)) datatable(data) $$ \\[\\begin{align*} \\textbf{Maximize} &amp; \\ y = \\sum_{i\\in M}^{ }p_i\\cdot x_i \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i\\in M} x_i \\le\\ C \\\\ &amp; \\sum_{i\\in M} a_{i,j} \\cdot x_i \\le\\ A_j, \\ \\ \\forall j \\in N \\\\ &amp; x_i \\ge 0 \\\\ \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Products in M} \\\\ &amp; j = \\text{Additives in N} \\\\ &amp; p_i = \\text{Profit margin for product i} \\\\ &amp; C = \\text{Plant capacity} \\\\ &amp; A_j = \\text{Additive j available} \\\\ &amp; a_{i,j} = \\text{Quantity of additive j required per barrel of product i} \\\\ &amp; x_i = \\text{Quantity of product i to produce} \\\\ \\end{align*}\\] $$ rm(x) n = 2 #Number of products High and Supreme C = filter(data, Type == &quot;Plant&quot;) %&gt;% select(Capacity) %&gt;% .$Capacity a = as.matrix(filter(data, Type %in% c(&quot;Additive A&quot;,&quot;Additive B&quot;)) %&gt;% select(High, Supreme)) A = filter(data, Type %in% c(&quot;Additive A&quot;,&quot;Additive B&quot;)) %&gt;% select(Capacity) %&gt;% .$Capacity p = filter(data, Type == &quot;Profit&quot;) %&gt;% select(High, Supreme) %&gt;% gather() %&gt;% .$value model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # minimize travel distance set_objective(sum_expr(p[i]*x[i], i = 1:n), &quot;max&quot;) %&gt;% # you cannot exceed the Plant Capacity add_constraint(sum_expr(x[i], i = 1:n) &lt;= C) %&gt;% #You cannot exceed aditivie capacity add_constraint(sum_expr(x[i] * a[j,i], i = 1:n) &lt;= A[j], j = 1:n) model$constraints ## [[1]] ## $lhs ## expression(x[1L] + x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(110) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(c(High = 3) * x[1L] + c(Supreme = 2) * x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(300) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(x[1L] * c(High = 1) + c(Supreme = 3) * x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(280) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## * 0: obj = -0.000000000e+00 inf = 0.000e+00 (2) ## * 2: obj = 1.900000000e+04 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## 2 integer variables, none of which are binary ## Integer optimization begins... ## + 2: mip = not found yet &lt;= +inf (1; 0) ## + 2: &gt;&gt;&gt;&gt;&gt; 1.900000000e+04 &lt;= 1.900000000e+04 0.0% (1; 0) ## + 2: mip = 1.900000000e+04 &lt;= tree is empty 0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 19000 #result solution result$solution ## x[1] x[2] ## 25 85 #Duals get_column_duals(result) ## [1] NA 1.1.2 Practice Problems 1.1.2.1 Handmade Baskets \\[ P = (x/73)^2-(x/95)+0.92 \\] P &lt;- function(x){(x/73)^2-(x/95)+0.92} #Data created for plot, using mutate on the function x &lt;- seq(-100,200,1) data &lt;- data &lt;- data.frame(x) %&gt;% mutate(y = P(x)) min = data[data$y == min(data$y),] #cheating :P #Ploting with a marker on the optimal solution plot_ly(data, x = ~x, y = ~y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_markers(y = min$y, x = min$x) #Part 1: Price Functio #Question1: How much will it charge with 5 basket&#39;s order ? P(5) ## [1] 0.8720597 #Question2: What is the first derivative of the price function? library(Ryacas) x &lt;- Sym(&quot;x&quot;) s &lt;- expression((x/73)^2-(x/95)+0.92) deriv(s,x) #Didn&#39;t work TO DO ## expression({ ## .expr1 &lt;- x/73 ## .value &lt;- .expr1^2 - x/95 + 0.92 ## .grad &lt;- array(0, c(length(.value), 1L), list(NULL, c(&quot;x&quot;))) ## .grad[, &quot;x&quot;] &lt;- 2 * (1/73 * .expr1) - 1/95 ## attr(.value, &quot;gradient&quot;) &lt;- .grad ## .value ## }) #Question3: Second Derivative x &lt;- Sym(&quot;x&quot;) s &lt;- expression(-1/95 + (2*x)/5329) deriv(s,x) #worked ## expression({ ## .value &lt;- -1/95 + 2 * x/5329 ## .grad &lt;- array(0, c(length(.value), 1L), list(NULL, c(&quot;x&quot;))) ## .grad[, &quot;x&quot;] &lt;- 2/5329 ## attr(.value, &quot;gradient&quot;) &lt;- .grad ## .value ## }) #Question4: Lowest Unit Price result &lt;- optimize(P,interval = c(-100,100), maximum = F) print(result) ## $minimum ## [1] 28.04737 ## ## $objective ## [1] 0.7723823 1.1.2.2 Maximizing Storage \\[ \\begin{align*} \\textbf{Minimize} &amp; \\ Z = x*y \\\\ \\textbf{st.} \\\\ &amp; 2*x+2*y = 26.7 \\end{align*} \\] Simplifying \\(2*x+2*y = 26.7\\) as \\(y = (26.7 - 2*x)/2\\) is possible to change the optimization problem to a single variable: \\[ \\begin{align*} \\textbf{Minimize} &amp; \\ Z\\ =x\\cdot\\ \\left(\\frac{\\left(26.7-2\\cdot x\\right)}{2}\\right)\\\\ \\end{align*} \\] Solving: f &lt;- function(x){x*((26.7 - 2*x)/2)} result &lt;- optimize(f,interval = c(-100,100), maximum = T) print(result) ## $maximum ## [1] 6.675 ## ## $objective ## [1] 44.55562 Let’s check the result in the plot #Data created for plot, using mutate on the function x &lt;- seq(-100,100,0.1) data &lt;- data &lt;- data.frame(x) %&gt;% mutate(y = f(x)) #Ploting with a marker on the optimal solution plot_ly(data, x = ~x, y = ~y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_markers(y = result$objective, x = result$maximum) 1.1.2.3 Marketing MagicPuppy \\[ N = 1700 \\left ( \\frac{x}{90} - \\left ( \\frac{x}{90} \\right ) ^2 \\right ) \\] f &lt;- function(x){1700*(x/90-(x/90)^2)} #Question1: First derivative x &lt;- Sym(&quot;x&quot;) s &lt;- expression(1700*(x/90-(x/90)^2)) deriv(s,x) #Didn&#39;t work TO DO ## expression({ ## .expr1 &lt;- x/90 ## .expr5 &lt;- 1/90 ## .value &lt;- 1700 * (.expr1 - .expr1^2) ## .grad &lt;- array(0, c(length(.value), 1L), list(NULL, c(&quot;x&quot;))) ## .grad[, &quot;x&quot;] &lt;- 1700 * (.expr5 - 2 * (.expr5 * .expr1)) ## attr(.value, &quot;gradient&quot;) &lt;- .grad ## .value ## }) #Question2: How many units should be given away in the campaign in order to maximize its positive impact? result &lt;- optimize(f,interval = c(-100,200), maximum = T) print(result) ## $maximum ## [1] 45 ## ## $objective ## [1] 425 x &lt;- seq(-50,100,1) data &lt;- data &lt;- data.frame(x) %&gt;% mutate(y = f(x)) #Ploting with a marker on the optimal solution plot_ly(data, x = ~x, y = ~y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_markers(y = result$objective, x = result$maximum) 1.1.2.4 CureBase Cancer Institute \\[ W = \\left ( m^{x^{2}} \\right )\\left ( n^{-x} \\right )\\left ( z^7 \\right ) \\] #Question what is the value of x at the maximum value of W , given that m=0.06 , n=0.14 , z=0.15 ?) f &lt;- function(x){0.06^(x^2)*(0.14^(-x))*0.15^7} result &lt;- optimize(f,interval = c(-1,1), maximum = T) print(result) ## $maximum ## [1] 0.3494179 ## ## $objective ## [1] 2.408895e-06 x &lt;- seq(-1,1,0.1) data &lt;- data &lt;- data.frame(x) %&gt;% mutate(y = f(x)) #Ploting with a marker on the optimal solution plot_ly(data, x = ~x, y = ~y, type = &#39;scatter&#39;, mode = &#39;lines&#39;) %&gt;% add_markers(y = result$objective, x = result$maximum) 1.1.2.5 Santa’s Molding Company data &lt;- tibble(Type = c(&quot;Profit&quot;,&quot;Time&quot;,&quot;Cubic Area&quot;, &quot;index capacity&quot;), Toy = c(25,13,33,75), doll = c(25,15,25,70), Capacity = c(NA,1440, 3000, NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Maximize} &amp; \\ y = \\sum_{i=1}^{N} p_i\\cdot x_i \\\\ \\textbf{subject to}\\\\ &amp; x_i \\le\\ c_i \\ \\ \\forall i \\in N \\\\ &amp; \\sum_{i=1}^{N} t_{i} \\cdot x_i \\le\\ 1440 \\\\ &amp; \\sum_{i=1}^{N} a_{i} \\cdot x_i \\le\\ 3000 \\\\ &amp; x_i \\ge 0 \\\\ \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Products in N} \\\\ &amp; p_i = \\text{Profit margin for product i} \\\\ &amp; c_i = \\text{Product daily capacity} \\\\ &amp; t_i = \\text{Time to mold product i} \\\\ &amp; a_i = \\text{Cubic inches of product i} \\\\ &amp; x_i = \\text{Quantity of product i to mold} \\\\ \\end{align*}\\] $$ If we look closer on the dataframe, we can set constraints 2 and 3 as one with a matrix including capacity constraints, but for math notation I’ve set them differently since they are 2 different types of entities. rm(x) n = 2 #Number of products Toy and doll c = filter(data, Type == &quot;index capacity&quot;) %&gt;% select(Toy,doll) %&gt;% gather() %&gt;% .$value #index_capacity a = as.matrix(filter(data, Type %in% c(&quot;Time&quot;,&quot;Cubic Area&quot;)) %&gt;% select(Toy,doll)) #constraints left hand C = filter(data, Type %in% c(&quot;Time&quot;,&quot;Cubic Area&quot;)) %&gt;% select(Capacity) %&gt;% .$Capacity #constraints right hand p = filter(data, Type == &quot;Profit&quot;) %&gt;% select(Toy,doll) %&gt;% gather() %&gt;% .$value #profit model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # minimize travel distance set_objective(sum_expr(p[i]*x[i], i = 1:n), &quot;max&quot;) %&gt;% # you cannot exceed the Plant Capacity add_constraint(x[i] &lt;= c[i], i= 1:n) %&gt;% #You cannot exceed aditivie capacity add_constraint(sum_expr(x[i] * a[j,i], i = 1:n) &lt;= C[j], j = 1:n) model$constraints ## [[1]] ## $lhs ## expression(x[1L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(75) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(70) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(c(Toy = 13) * x[1L] + c(doll = 15) * x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(1440) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[4]] ## $lhs ## expression(c(Toy = 33) * x[1L] + c(doll = 25) * x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(3000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 4 rows, 2 columns, 6 non-zeros ## * 0: obj = -0.000000000e+00 inf = 0.000e+00 (2) ## * 3: obj = 2.576470588e+03 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 4 rows, 2 columns, 6 non-zeros ## 2 integer variables, none of which are binary ## Integer optimization begins... ## + 3: mip = not found yet &lt;= +inf (1; 0) ## Solution found by heuristic: 2575 ## + 3: mip = 2.575000000e+03 &lt;= tree is empty 0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 2575 #result solution result$solution ## x[1] x[2] ## 53 50 #Duals get_column_duals(result) ## [1] NA Let’s solve the questions P &lt;- function(x,y){25*x+25*y} #Question 1: Graphical selection #Question 2: What is the value of x = 70 and y= 30 P(70,30) ## [1] 2500 #Question 3: What is the value of x = 50 and y= 53 P(50,53) ## [1] 2575 #Question 3: What is the value of x = 50 and y= 53 P(20,75) ## [1] 2375 1.1.2.6 Crazy Cereal data &lt;- tibble(Type = c(&quot;Sugary&quot;,&quot;Regular&quot;,&quot;Capacity&quot;), Sugar = c(0.66,0.21,2000), Corn_Flake = c(0.34,0.79,4000), Profit = c(0.94,0.82,NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Maximize} &amp; \\ y = \\sum_{i=1}^{N} p_i \\cdot x_{i} \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\le C_j, \\ j \\in M \\\\ &amp; x_{i} \\ge 0, \\ x \\in \\mathbb{Z} \\\\ \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Products in N} \\\\ &amp; j = \\text{Components of N = M} \\\\ &amp; p_i = \\text{Profit margin for product i} \\\\ &amp; a_{i,j} = \\text{components for product i} \\\\ &amp; C_j = \\text{Component capacity} \\\\ &amp; x_{i} = \\text{Quantity of product} \\\\ \\end{align*}\\] $$ rm(x) ## Warning in rm(x): object &#39;x&#39; not found n = 2 #Number of products Sugary and Regular m = 2 #Number of components Sugar and Corn_Flake #Let&#39;s do some roots R instead of dplyr :) C = as.matrix(data[data$Type == &quot;Capacity&quot;,c(&quot;Sugar&quot;, &quot;Corn_Flake&quot;)]) a = as.matrix(data[data$Type %in% c(&quot;Sugary&quot;,&quot;Regular&quot;),c(&quot;Sugar&quot;, &quot;Corn_Flake&quot;)]) p = as.matrix(data$Profit[1:2]) model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(p[i] * x[i], i = 1:n), &quot;max&quot;) %&gt;% #You cannot exceed component capacity add_constraint(sum_expr(x[i] * a[i,j], i = 1:m) &lt;= C[j], j = 1:n) model$constraints ## [[1]] ## $lhs ## expression(c(Sugar = 0.66) * x[1L] + c(Sugar = 0.21) * x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(2000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(c(Corn_Flake = 0.34) * x[1L] + c(Corn_Flake = 0.79) * ## x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(4000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 2 rows, 2 columns, 4 non-zeros ## * 0: obj = -0.000000000e+00 inf = 0.000e+00 (2) ## * 2: obj = 5.117333333e+03 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 2 rows, 2 columns, 4 non-zeros ## 2 integer variables, none of which are binary ## Integer optimization begins... ## + 2: mip = not found yet &lt;= +inf (1; 0) ## Solution found by heuristic: 5116.34 ## + 6: &gt;&gt;&gt;&gt;&gt; 5.116460000e+03 &lt;= 5.116460000e+03 0.0% (2; 1) ## + 6: mip = 5.116460000e+03 &lt;= tree is empty 0.0% (0; 5) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 5116.46 #result solution result$solution ## x[1] x[2] ## 1644 4355 #Duals get_column_duals(result) ## [1] NA 1.1.2.7 Jim’s Meat Packing Company data &lt;- tibble(Cut = c(&quot;Chuck&quot;,&quot;Sirloin&quot;,&quot;Restriction&quot;), Lean_Meat = c(0.09,0.6,0.3), Fat_Meat = c(0.02,0.06,0.05), Cost = c(9.3,8.4,NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Minimize} &amp; \\ y = \\sum_{i=1}^{N} c_i \\cdot x_{i} \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\ge \\sum_{i=1}^{N} R_j \\cdot x_{i}, \\ \\ j \\in N=1 \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\le \\sum_{i=1}^{N} R_j \\cdot x_{i}, \\ \\ j \\in N=2 \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\ge 50 \\\\ &amp; x_{i} \\ge 0, \\ x \\in \\mathbb{Z} \\\\ \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Type of cut in N} \\\\ &amp; j = \\text{Type of meat} \\\\ &amp; c_i = \\text{Cost for product i} \\\\ &amp; a_{i,j} = \\text{components for product i} \\\\ &amp; R_j = \\text{Restriction capacity} \\\\ &amp; x_{i} = \\text{Quantity of product} \\\\ \\end{align*}\\] $$ rm(x) ## Warning in rm(x): object &#39;x&#39; not found n = 2 #Number of products Sugary and Regular m = 2 #Number of components Sugar and Corn_Flake #Another way of subsetting data in R R = as.matrix(data[3,2:3]) a = as.matrix(data[1:2,2:3]) c = as.matrix(data[1:2,4]) model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(c[i] * x[i], i = 1:n), &quot;min&quot;) %&gt;% #yay add_constraint(sum_expr(x[i], i = 1:n) &gt;= 50) %&gt;% #You cannot exceed component capacity add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &gt;= sum_expr(x[i], i = 1:n)*R[j], j = 1) %&gt;% add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &lt;= sum_expr(x[i], i = 1:n)*R[j], j = 2) model$constraints ## [[1]] ## $lhs ## expression(x[1L] + x[2L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(50) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(c(Lean_Meat = 0.09) * x[1L] + c(Lean_Meat = 0.6) * ## x[2L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(0.3 * x[1L] + 0.3 * x[2L]) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(c(Fat_Meat = 0.02) * x[1L] + c(Fat_Meat = 0.06) * ## x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(0.05 * x[1L] + 0.05 * x[2L]) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## 0: obj = 0.000000000e+00 inf = 5.000e+01 (1) ## 2: obj = 4.464705882e+02 inf = 0.000e+00 (0) ## * 3: obj = 4.312500000e+02 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## 2 integer variables, none of which are binary ## Integer optimization begins... ## + 3: mip = not found yet &gt;= -inf (1; 0) ## + 4: &gt;&gt;&gt;&gt;&gt; 4.317000000e+02 &gt;= 4.317000000e+02 0.0% (1; 0) ## + 4: mip = 4.317000000e+02 &gt;= tree is empty 0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 431.7 #result solution result$solution ## x[1] x[2] ## 13 37 #Duals get_column_duals(result) ## [1] NA I couldn’t find a proper function on shadow price calculation on ompr package, so lets try to calculate it ourselves! ModelIter &lt;- function(z){ model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(c[i] * x[i], i = 1:n), &quot;min&quot;) %&gt;% #yay add_constraint(sum_expr(x[i], i = 1:n) &gt;= z) %&gt;% #You cannot exceed component capacity add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &gt;= sum_expr(x[i], i = 1:n)*R[j], j = 1) %&gt;% add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &lt;= sum_expr(x[i], i = 1:n)*R[j], j = 2) %&gt;% solve_model(with_ROI(solver = &quot;glpk&quot;, verbose = F)) return(model$objective_value) } Iter_Results &lt;- tibble(constraint = seq(48,55,1)) %&gt;% mutate(Obj_value = as.numeric(map(constraint, ModelIter)), Marginal_value = round((Obj_value-lag(Obj_value,1)/(constraint-lag(constraint,1))),2)) datatable(Iter_Results) mean(Iter_Results$Marginal_value[2:length(Iter_Results)]) ## [1] 8.85 Marginal Value set as 8.85 got us an error, the answer was 8.63, would be good to understand what was made wrong in here. 1.1.2.8 John’s Shipping Company data &lt;- tibble(Fuel_Type = c(&quot;O_Type&quot;,&quot;D_Type&quot;,&quot;Restriction&quot;), Hydrogen_Conc = c(45,90,60), Oxygen_Conc = c(15,6,9), Cost = c(1.05,1.34,NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Minimize} &amp; \\ y = \\sum_{i=1}^{N} c_i \\cdot x_{i} \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\ge \\sum_{i=1}^{N} R_j \\cdot x_{i}, \\ \\ j \\in N=1 \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\le \\sum_{i=1}^{N} R_j \\cdot x_{i}, \\ \\ j \\in N=2 \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\ge G \\\\ &amp; x_{i} \\ge 0, \\ x \\in \\mathbb{Z} \\\\ \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Type of cut in N} \\\\ &amp; j = \\text{Type of meat} \\\\ &amp; c_i = \\text{Cost for product i} \\\\ &amp; a_{i,j} = \\text{components for product i} \\\\ &amp; R_j = \\text{Restriction capacity} \\\\ &amp; x_{i} = \\text{Quantity of product} \\\\ &amp; G = \\text{Minimum to be produced} \\\\ \\end{align*}\\] $$ rm(x) ## Warning in rm(x): object &#39;x&#39; not found n = 2 #Number of products Sugary and Regular m = 2 #Number of components Sugar and Corn_Flake z = 10000 #minimum to be produced #Another way of subsetting data in R R = as.matrix(data[3,2:3]) a = as.matrix(data[1:2,2:3]) c = as.matrix(data[1:2,4]) model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(c[i] * x[i], i = 1:n), &quot;min&quot;) %&gt;% #Produce at least the minimum required add_constraint(sum_expr(x[i], i = 1:n) &gt;= z) %&gt;% #Minimum component required add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &gt;= sum_expr(x[i], i = 1:n)*R[j], j = 1) %&gt;% #You cannot exceed component capacity add_constraint(sum_expr(x[i] * a[i,j], i = 1:n) &lt;= sum_expr(x[i], i = 1:n)*R[j], j = 2) model$constraints ## [[1]] ## $lhs ## expression(x[1L] + x[2L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(10000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(c(Hydrogen_Conc = 45) * x[1L] + c(Hydrogen_Conc = 90) * ## x[2L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(60 * x[1L] + 60 * x[2L]) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(c(Oxygen_Conc = 15) * x[1L] + c(Oxygen_Conc = 6) * ## x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(9 * x[1L] + 9 * x[2L]) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## 0: obj = 0.000000000e+00 inf = 1.000e+04 (1) ## 3: obj = 1.243333333e+04 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 3 rows, 2 columns, 6 non-zeros ## 2 integer variables, none of which are binary ## Integer optimization begins... ## + 3: mip = not found yet &gt;= -inf (1; 0) ## Solution found by heuristic: 12433.43 ## + 3: mip = 1.243343000e+04 &gt;= tree is empty 0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 12433.43 #result solution result$solution ## x[1] x[2] ## 3333 6667 #Duals get_column_duals(result) ## [1] NA 1.1.2.9 A New Office Plant data &lt;- tibble(Type = c(&quot;Product_1&quot;,&quot;Product_2&quot;,&quot;Product_3&quot;, &quot;Min&quot;, &quot;Max&quot;), Nitrogen = c(360,380,310,1800,2200), Potassium = c(30,20,20,100,100), cost = c(1.59,2.19,2.99,NA,NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Minimize} &amp; \\ y = \\sum_{i=1}^{N} c_i \\cdot x_{i} \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\ge Min_j, \\ \\ j \\in M \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\le Max_j, \\ \\ j \\in M \\\\ &amp; x_{i} \\ge 0 \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Type of product in N} \\\\ &amp; j = \\text{Type of component in M} \\\\ &amp; c_i = \\text{Cost for product i} \\\\ &amp; a_{i,j} = \\text{components for product i} \\\\ &amp; Min_j = \\text{Restriction of component} \\\\ &amp; Max_j = \\text{Restriction of component} \\\\ &amp; x_{i} = \\text{Quantity of product} \\\\ \\end{align*}\\] $$ rm(x) ## Warning in rm(x): object &#39;x&#39; not found n = 3 #Number of products m = 2 #Number of components #subsetting data to R min = as.matrix(data[4,2:3]) max = as.matrix(data[5,2:3]) a = as.matrix(data[1:3,2:3]) c = as.matrix(data[1:3,4]) model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;continuous&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(c[i] * x[i], i = 1:n), &quot;min&quot;) %&gt;% #Produce at least the minimum required add_constraint(sum_expr(x[i]*a[i,j], i = 1:n) &gt;= min[j], j = 1:m) %&gt;% #Dont exceed maximum required add_constraint(sum_expr(x[i]*a[i,j], i = 1:n) &lt;= max[j], j = 1:m) model$constraints ## [[1]] ## $lhs ## expression(c(Nitrogen = 360) * x[1L] + c(Nitrogen = 380) * x[2L] + ## c(Nitrogen = 310) * x[3L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(1800) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(c(Potassium = 30) * x[1L] + c(Potassium = 20) * x[2L] + ## c(Potassium = 20) * x[3L]) ## ## $sense ## [1] &quot;&gt;=&quot; ## ## $rhs ## expression(100) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(c(Nitrogen = 360) * x[1L] + c(Nitrogen = 380) * x[2L] + ## c(Nitrogen = 310) * x[3L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(2200) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[4]] ## $lhs ## expression(c(Potassium = 30) * x[1L] + c(Potassium = 20) * x[2L] + ## c(Potassium = 20) * x[3L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(100) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 4 rows, 3 columns, 12 non-zeros ## 0: obj = 0.000000000e+00 inf = 1.900e+03 (2) ## 2: obj = 1.095000000e+01 inf = 1.421e-14 (0) ## * 4: obj = 1.014285714e+01 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 10.14286 #result solution result$solution ## x[1] x[2] x[3] ## 0.4761905 4.2857143 0.0000000 #Duals get_column_duals(result) ## x[1] x[2] x[3] ## 0.000 0.000 1.365 #Question: How many mg of Nitrogen would your solution provide to the plant every day? (Please round your answer to integer number) result$solution[1]*a[1,1]+result$solution[2]*a[2,1] ## x[1] ## 1800 1.1.2.10 Rochak’s Ink Company data &lt;- tibble(Type = c(&quot;P_Cyan&quot;,&quot;P_Magenta&quot;,&quot;P_Yellow&quot;,&quot;Max&quot;), Stage1 = c(0.44,0.51,0.5,17*60^2), Stage2 = c(0.55,0.6,0.59,23*60^2), Demand = c(84000,72000,93000,NA), Profit = c(0.6,0.72,0.62,NA)) datatable(data) $$ \\[\\begin{align*} \\textbf{Maximize} &amp; \\ y = \\sum_{i=1}^{N} p_i \\cdot x_{i} \\\\ \\textbf{subject to}\\\\ &amp; \\sum_{i=1}^{N} x_{i} \\cdot a_{i,j} \\le Max_j, \\ \\ j \\in M \\\\ &amp; \\sum_{i=1}^{N} x_{i} \\le D_i \\\\ &amp; x_{i} \\ge 0, \\ x \\in \\mathbb{Z} \\\\ \\textbf{Where} \\\\ &amp; i = \\text{Type of product in N} \\\\ &amp; j = \\text{Production stage in M} \\\\ &amp; p_i = \\text{Profit for product i} \\\\ &amp; a_{i,j} = \\text{Time requirement for product i in stage j} \\\\ &amp; Max_j = \\text{Restriction of production time} \\\\ &amp; D_i = \\text{Demand for product} \\\\ &amp; x_{i} = \\text{Quantity of product} \\\\ \\end{align*}\\] $$ In this exercise, you’re willing to maximize profit given the demand. You don’t have to fulfill all of the demand, that’s why the $ {i=1}^{N} x{i} D_i$ constraint. rm(x) ## Warning in rm(x): object &#39;x&#39; not found n = 3 #Number of products m = 2 #Number of components #subsetting data to R D = as.matrix(data[1:3,4]) max = as.matrix(data[4,2:3]) a = as.matrix(data[1:3,2:3]) p = as.matrix(data[1:3,5]) model &lt;- MIPModel() %&gt;% # Variable of profit add_variable(x[i], i = 1:n, type = &quot;integer&quot;, lb = 0) %&gt;% # maximize profit set_objective(sum_expr(p[i] * x[i], i = 1:n), &quot;max&quot;) %&gt;% #Don&#39;t produce something you don&#39;t have demand for add_constraint(x[i] &lt;= D[i], i = 1:n) %&gt;% #Dont exceed maximum required add_constraint(sum_expr(x[i]*a[i,j], i = 1:n) &lt;= max[j], j = 1:m) model$constraints ## [[1]] ## $lhs ## expression(x[1L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(84000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[2]] ## $lhs ## expression(x[2L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(72000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[3]] ## $lhs ## expression(x[3L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(93000) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[4]] ## $lhs ## expression(c(Stage1 = 0.44) * x[1L] + c(Stage1 = 0.51) * x[2L] + ## c(Stage1 = 0.5) * x[3L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(61200) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; ## ## [[5]] ## $lhs ## expression(c(Stage2 = 0.55) * x[1L] + c(Stage2 = 0.6) * x[2L] + ## c(Stage2 = 0.59) * x[3L]) ## ## $sense ## [1] &quot;&lt;=&quot; ## ## $rhs ## expression(82800) ## ## attr(,&quot;class&quot;) ## [1] &quot;model_constraint&quot; #Solve result &lt;- solve_model(model, with_ROI(solver = &quot;glpk&quot;, verbose = TRUE)) ## &lt;SOLVER MSG&gt; ---- ## GLPK Simplex Optimizer, v4.57 ## 5 rows, 3 columns, 9 non-zeros ## * 0: obj = -0.000000000e+00 inf = 0.000e+00 (3) ## * 3: obj = 8.522181818e+04 inf = 0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.57 ## 5 rows, 3 columns, 9 non-zeros ## 3 integer variables, none of which are binary ## Integer optimization begins... ## + 3: mip = not found yet &lt;= +inf (1; 0) ## Solution found by heuristic: 85221.6 ## + 11: &gt;&gt;&gt;&gt;&gt; 8.522172000e+04 &lt;= 8.522179840e+04 &lt; 0.1% (5; 0) ## + 12: mip = 8.522172000e+04 &lt;= tree is empty 0.0% (0; 9) ## INTEGER OPTIMAL SOLUTION FOUND ## &lt;!SOLVER MSG&gt; ---- #Optimal Value result$objective_value ## [1] 85221.72 #result solution result$solution ## x[1] x[2] x[3] ## 55641 71996 0 1.1.2.11 Pasteur Cheese Factory "]
]
